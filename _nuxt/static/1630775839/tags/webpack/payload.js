__NUXT_JSONP__("/tags/webpack", (function(a){return {data:[{blogsByTag:[{slug:"de-khong-danh-nhau-khi-to-chuc-style-cho-ecommerce-site",description:"Bài viết này dựa trên một truyền thuyết có thật... à nhầm một câu chuyện thực tế về cách mình và team đã cùng nhau giải quyết các vấn đề style khi làm một page eCommerce với khoảng 40+ screens ( desktop + mobile ). Bằng một cách thần kì nào đó không có cuộc đánh nhau nào xảy ra trong suốt quá trình code. Giờ thì bắt đầu thôi.",title:"Để không đánh nhau khi tổ chức style cho eCommerce site",image:"https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630769848\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F09\u002F04-banner_oxfx2z.png",tags:["scss",a,"shopify"],published:"2020-09-04",contentBeforeJson:"\n## Đặt vấn đề\nChuyện diễn ra vào một ngày đẹp trời nọ. Ngày ấy mình chỉ code các app ( có thể hiểu là một dạng plugin ) cho nền tảng Shopify. Mọi thứ khá êm đềm vì khi ấy toàn bộ style của 1 app khá nhỏ. Quanh quẩn căng lắm 1000+ dòng ( kết quả bundle, tính chung cả project ). Ae tập trung làm logic là chủ yếu, không quá đặt nặng về style, thậm chí có vài vấn đề bọn mình còn ngồi tự bịa với nhau.\nThế rồi một ngày nọ bọn mình nhận yêu cầu làm theme cho Shopify ( do đội designer bên mình thiết kế ) , và outsource 1 shop khác ( cũng base trên Shopify nhưng do khách có thiết kế sẵn rồi ). Sơ sơ thì design trông như thế này \n\n![design figma](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630770598\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F09\u002F04-design.png)\n\nThì kia là bản Desktop nhé, chúng mình có 1 số lượng screen tương tự cho bản Mobile nữa. Và bọn mình bắt đầu triển khai project cho đến khi Bùm, vấn đề đã xuất hiện.\n\n## Atomic CSS hay SCSS\nViệc đầu tiên đau đầu là mình phân vân giữa việc để team code Atomic CSS hay là dùng SCSS. Về Atomic CSS thì [Tailwind](https:\u002F\u002Ftailwindcss.com\u002F) là cái tên hot trend nổi đình đám. Mình không đi sâu đến Atomic CSS ở đây, có thể mình sẽ viết ở một bài viết khác vì nó là trend và cũng có khá nhiều ưu điểm. Lược sơ qua có thể kế đến như :\n\n - Không phải suy nghĩ chuyện nên đặt tên class cha thế nào, class con thế nào, cháu thế nào cho đau đầu.\n -  Làm prototype với tốc độ ánh sáng, dựng lên cái khuân chỉ trong tích tắc \n - Bundle size nhẹ hơn, load trang nhanh hơn. Thành thật mà nói thì đây là cái làm mình đắn đo nhất. Vì cá nhân mình rất quan tâm đến performance của page ( chưa kể có khách hàng còn rất khó tính ), Shopify lúc đó cũng rất khuyến khích các trang có tốc độ nhanh. Mình đã xem một vài bài benchmark thì kể ra thích Tailwind thật.\n - Đỡ phải chia cấu trúc, đặt style ở đâu này kia. Team mình code Vue và Liquid ( của Shopify ) là chủ yếu, chúng dùng khá nhiều template. Đặt luôn vào template như thế thì còn gì bằng.\n - Trend, đùa, đã là trend thì ai chẳng thích đú. Ae trong team thì lại càng thích, và mình thì... ừ cũng thích.\n \n Ngồi kể cả đống kia ra, ấy thế mà, cuối cùng sau tất cả, mình và team vẫn chọn code SCSS, tại sao vậy ?\n Vì chúng mình làm thử. Rất nhanh sau đó, mình đã nhận ra một số điểm mà có lẽ team mình chưa nên dùng Atomic CSS ở thời điểm này. Sau rất nhiều đêm mất ngủ, mình đành setup lại, cấu trúc lại, tạm biệt cô em Tailwind sexy này \n\n- Tất nhiên lý do đầu là các bố các phải học, từng ông trong team phải mò vào docs của Tailwind và bắt đầu đọc thần chú với hàng nghìn class có sẵn của nó. Với mình thì nó hệ thống, dễ nhớ. Tuy nhiên, không phải là một lựa chọn bắt đầu project nhanh. \n - Loạn xì ngậu class, chiến trường class, nghĩa địa atomic... Âu, đúng vậy. Giời ơi nó lắm class vô cùng luôn. Khác với khi làm Admin Dashboard hay những thứ tương tự thế, thì thực sự các web, đặc biệt là e-commerce thì đúng là ối dồi ôi. Design của nó rất phức tạp, nhiều chi tiết nhỏ lỉnh kỉnh. Chưa kể yêu cầu Pixel Perfect đến từ sếp. Một cái div nhỏ khi ấy kéo dài lê thê là chuyện thường. Mà Liquid lại còn là một kiểu viết logic luôn trong HTML. Thật không tin nổi, mình đang đặt cả template, logic và style vào cùng một chỗ.\n - Một page ecommerce thì có rất nhiều element, nhiều component nhỏ. Như vậy khi atomic class tràn đầy trên template, việc thay đổi style của 1 element sẽ rất khó. Bạn sẽ phải tìm và thay một đống ( tương tự nếu có ) trên template đó. \n- Vẫn phải custom khá nhiều. Một số trường hợp design phức tạp bản thân Tailwind vẫn chưa thể cover với đống class atomic của nó được, mình đành vẫn tạo file scss rồi custom class vào đó.\n\nĐứng trước các vấn đề đó, sau một lần nữa lại những đêm mất ngủ, mình đành quyết định dùng SCSS. Nhưng câu hỏi đặt ra là mình sẽ dùng như thế nào để phù hợp với project đây.\n\n## Đi tìm chiếc structure hoàn hảo\nBan đầu, mình nghĩ là mình có thể chia theo page, cứ style của page nào thì viết vào file SCSS của page đấy.\n\n```\n|– pages\u002F  \n| |– _home.scss \u002F\u002F Home specific styles  \n| |– _about.scss \u002F\u002F About specific styles  \n| |– _contact.scss \u002F\u002F Contact specific styles  \n  ...\n ...\n – main.scss\n```\n\nThế rồi chỉ vài ngày sau mình nhận ra vấn đề của việc này, đó chính là quá trình maintain và update. Thử tượng tượng bạn đang muốn sửa cái Product Card của một người ae nào đó trong team viết. Bạn tìm đến được file template của Product Card rồi, nhanh chóng sau đó bạn tìm thấy class mà bạn muốn sửa. Nhưng no, css của file này đâu. Bạn nhanh trí nhớ ra, à hình như Product Card nằm trong trang Home, như vậy mình có thể tìm nó ở file `_home.scss` bên trên ( hoặc ông nào dùng Search của Vim hay Vscode để search cũng được nhé ). Bạn mò đến file scss này và bùm, ngoài code style của Product Card ra bạn còn thấy style của rất nhiều các thành phần khác có trong Home page nữa, như là Banner này, Slider này... Vậy thì có khi nào chỉ vì sửa Product Card mình lỡ tay động nhầm vào một cái khác không, chưa kể tìm ra mà sửa cũng mệt ( vì có mấy ông không viết theo nhóm, cứ đè ra đít file mà viết, thành ra các phần cứ đan xen đan xen nhau ).\n\nThế là mình phải nghĩ cách. Đúng là không thể thế này được. Cần chia nhỏ hơn. Code style nên đi kèm theo các snipets, component. Như vậy vừa dễ quản lý, lại dễ tìm, dễ sửa. Nhanh chóng ngay sau đó, mình bắt tay vào config lại Webpack cho project và kết quả ra như này\n\n![3 file](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630772721\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F09\u002F04-3-file.png)\n\nShopify lúc ấy chỉ cho phép 1 file bundle js, 1 file bunlde css cuối cùng, sử dụng cấu trúc phẳng. Nhưng nhờ có Webpack, mình đã tạo được thành từng folder như thế này. Sau đó mình sẽ tự động tìm hết các file `.scss` và `.ts` để merge lại rồi bundle ra thành `css` + `js` tương ứng.  Điều lợi của config này như mình đã nói bên trên, code vừa được tách ra thành logic, template, style ( khá giống Vue, Angular ) lại còn dễ tìm, dễ quản lý, dễ sửa.\n\n## Nâng cấp tiếp cấu trúc\n\nMọi thứ êm đẹp rồi mà, nâng cấp tiếp làm gì ?\nỪa thì có êm đẹp, anh em trong team lúc này đã đỡ đấm nhau hơn, nhưng mà vẫn chưa tối ưu. \n\n - Một site lớn như thế này, mình có thể tận dụng bộ grid system của Bootstrap 4 không, có chứ ( mình tách ra chỉ lấy đúng grid của Bootstrap, các phần khác mình không lấy ). \n - Khách yêu cầu sản phẩm phải có 2 theme, với 2 trường phái màu sắc khác nhau, 2 phong cách thiết kế khác nhau thì bây giờ làm thế nào ?\n -  Code reset CSS đặt ở đâu ?\n - Nhu cầu responsive, nhu cầu center element... ae ngày viết cả trăm lần. Thế không lẽ cứ mạnh ai người đấy viết ? Có thể chỉ để một người viết rồi ae dùng chung không ?\n - Sử dụng thư viện slider từ bên ngoài, giờ team muốn biến tấu đi, muốn custom lại nó một chút cho hợp với dự án, thế thì đặt ở đâu, custom ở đâu ?\n - ... vân vân mây mây\n \n Đúng thật là không ổn. Nên nhớ là team đang dùng SCSS cơ mà, nếu cứ code thế này thì khác gì dùng CSS, chẳng tận dụng được tí nào sức mạnh của nó cả. \n Và mình bắt đầu lùng sục các project trên git, tham khảo các dự án đã có, với mong muốn giải quyết vấn đề trong êm đẹp. Và thật may, cuối cùng mình đã tìm được. Ngay lập tức, mình áp dụng nó vào project \n ```\n sass\u002F  \n|  \n|– abstracts\u002F (or utilities\u002F)  \n| |– _variables.scss \u002F\u002F Sass Variables  \n| |– _functions.scss \u002F\u002F Sass Functions  \n| |– _mixins.scss \u002F\u002F Sass Mixins  \n|  \n|– base\u002F  \n| |– _reset.scss \u002F\u002F Reset\u002Fnormalize  \n| |– _typography.scss \u002F\u002F Typography rules  \n|  \n|– components\u002F (or modules\u002F)  \n| |– _buttons.scss \u002F\u002F Buttons  \n| |– _carousel.scss \u002F\u002F Carousel  \n| |– _slider.scss \u002F\u002F Slider  \n|  \n|– layout\u002F  \n| |– _navigation.scss \u002F\u002F Navigation  \n| |– _grid.scss \u002F\u002F Grid system  \n| |– _header.scss \u002F\u002F Header  \n| |– _footer.scss \u002F\u002F Footer  \n| |– _sidebar.scss \u002F\u002F Sidebar  \n| |– _forms.scss \u002F\u002F Forms  \n|  \n|– pages\u002F  \n| |– _home.scss \u002F\u002F Home specific styles  \n| |– _about.scss \u002F\u002F About specific styles  \n| |– _contact.scss \u002F\u002F Contact specific styles  \n|  \n|– themes\u002F  \n| |– _theme.scss \u002F\u002F Default theme  \n| |– _admin.scss \u002F\u002F Admin theme  \n|  \n|– vendors\u002F  \n| |– _bootstrap.scss \u002F\u002F Bootstrap  \n| |– _jquery-ui.scss \u002F\u002F jQuery UI  \n|  \n`– main.scss \u002F\u002F Main Sass file\n ```\n \n Ầu, thật đẹp. Cái này về từng folder có nhiệm vụ gì chắc mình không cần nói lại để tránh bài viết này dài. Cái này bạn có thể lên google search từ khoá ` sass 7 in 1 partern ` là được. \n À nhưng khoan đã, cấu trúc này đẹp đấy, rõ ràng đấy nhưng nếu import  cả 100+ file kia vào file `main.scss` thì sẽ thật kinh. Mình liền nảy sinh ra idea update lại như thế này. Ở mỗi một folder, mình thêm 1 file có dạng `_ten_folder-dir.scss`\n ![scss dir](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630774433\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F09\u002F04-scss-dir.png)\n \n Như bạn thấy, thay vì import tất cả các file vào `main.scss` thì ở mỗi folder ( trong 7 folder kia ) mình tạo ra 1 file `dir`.  Mình sẽ import toàn bộ file của folder đấy vào file `dir` tương ứng. Cuối cùng, sau khi có 7 file `dir` thì mình import cả 7 file này vào file `main.scss`. Thế là xong. File `main.scss` lúc này cũng đươc gọn hơn rất nhiều.\n```scss\n@import  '.\u002Fvendors\u002Fvendor-dir';\n@import  '.\u002Futils\u002Futils-dir';\n@import  '.\u002Fpages\u002Fpages-dir';\n@import  '.\u002Flayout\u002Flayout-dir';\n@import  '.\u002Fcomponents\u002Fcomponents-dir';\n@import  '.\u002Fsnippet\u002Fbackground-image';\n@import  '.\u002Fsections\u002Fsections-dir';\n@import  '.\u002Fbase\u002Fbase-dir';\n@import  '.\u002Fhelpers\u002Fhelpers-dir';\n\n\u002F* Auto impo@import all scss file from Theme folder *\u002F\n\u002F* Using @see https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fimpo@import-glob-loader *\u002F\n@import  \"..\u002F..\u002Fshopify\u002F**\u002F*.scss\";\n\n\u002F*\n* Code chung\n*\u002F\n@import  '.\u002Fgeneral';\n@import  '.\u002FvueGeneral';\n```\n\n## Hết\nVà thế là hết. Câu chuyện cuối cùng cũng đã có hồi kết.\nỞ thời điểm hiện tại thì đây là một cấu trúc mà mình thấy khá là tâm đắc. Ít nhất thì nó cũng giúp cho ae làm việc trong êm đẹp. Mỗi ngày đi làm nhìn nhau với tình thương mến thương. Không như ngày trước thỉnh thoảng đang làm lại có bố \" Ơ thằng kia code cái A này mày để ở đâu đấy\", hay là \"Ơ mày sửa kiểu *** gì hỏng hết style cái B của tao rồi \". Nghe chỉ muốn quay sang sút cho mỗi thằng phát.\nNên giờ yên bình rồi, kể được như thế, mình cũng vui vì không bõ công những đêm nghĩ cách. Thời gian đi fix với đi chửi nhau kia thì đi lên Now, lên Baemin đặt cho nhau cốc trà sữa có phải tình thương mến thương không.\nCuối tuần ngồi kể lể tí, đi nghe nhạc tí cho thư giãn. Hà Nội dạo này giãn cách, năm cô vít thứ 2 sau công nguyên,  word from home chán quá.\nPai pai !!!\n"},{slug:"webpack-ki-su-boc-tack",description:"Một câu chuyện thú vị trong việc setup một config hoàn hảo cho project của team mình. Với các tình tiết ly kì, hấp dẫn kết hợp cùng văn phong của một con người đã từng thức đến 4h sáng chỉ vì Search google không ra lỗi cũng như nhận kha khá gạch đá của ae trong team nên ức quá không ngủ được",title:"Webpack, nhật kí bóc tách",image:"https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578053\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-banner_ufhb7w.png",tags:[a],published:"2020-08-30",contentBeforeJson:"\n## Đặt vấn đề\nNgày mới học đến SCSS, công cụ đầu tiên mình dùng để bundle là Gulp. Một trong những điều mình thích nhất ở nó là config kiểu Pipeline, rất dễ đọc. Sau này thì để phục vụ cho công việc thì mình có dùng Webpack, Vite ( đối với các project build site ) và một chút Rollup ( đối với các lib ), hơn cả trong số này là Webpack. Và cũng giống như một số người config webpack từ đầu, mình cũng bị ngợp và thật sự là hơi rối. \nVí dụ như đây là một file config webpack hồi ấy của mình\n\n![Webpack](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578053\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-1_hjhbzl.png)\n\n\nAll in one trong một file cho nó nhanh. Nếu có config nào cần sự khác nhau giữa môi trường development và production thì mình sẽ dùng env để check như chỗ devtool kia. Mọi thứ ok, project mượt mà, fix phiếc dễ dàng, căn bản project cũng nhỏ, chẳng có gì lắm, quanh quẩn 5, 60 lines là xong rồi. \n\n## Đến công chuyện\n### Bối cảnh \nThì ai cũng phải lớn, project cũng không chỉ có bunlde cái này thành cái kia, ae trong team thì cũng yêu cầu nhiều hơn, các require của project cũng khó hơn. Thế là dẫn đến việc file config của mình lúc này phình khổng lồ.\nThành thực mà nói, ở một hai project đầu, dù config đã lên đến hơn 100, 150 lines thì mình vẫn để đấy. Vì sao, vì nó vẫn chạy. Nó vẫn chạy ngon, bundle production cuối cũng đúng ý ae muốn. Nhưng khổ nỗi là nếu có sửa gì đó thì ối dồi ôi. Hoặc khi sang project mới, nhìn lại đống config cũ chán chẳng thèm config sang. Ngày đấy may mà có các ae trong team Frontend của mình. Các ae như các tester, vì mình là người config, nên trong quá trình code ae đóng vai trò lớn trong việc giúp mình xem config đấy có sai ở đâu không, ae code có còn lỗi gì không blo bla. Cứ mỗi lần sửa ấy mà nó lại hoàn thiện hơn một chút. Mình cũng bị ăn gạch đá dẫn đến google nhiều hơn một chút. À đấy, sửa cũng phải sửa nhanh cơ, lại còn phải khéo, vì nếu ae đã lỡ code được nhiều rồi, project phình to rồi, mà đùng cái mình hâm dở bảo ae đổi lại cấu trúc thì chắc gạch đá đầy nhà. \nSau cái đợt đấy thì mình khôn lên, không config all in one như kia nữa. Bắt đầu biết chia làm các config khác nhau.\n### Chia thử \nVì sao lại có chuyện chia làm config khác nhau. Vì đơn giản chúng ta có 2 môi trường code khác nhau, development và production. Các bạn cũng thừa hiểu là kể ra những sự khác nhau giữa 2 môi trường này có mà cả ngày. \nMột ví dụ đơn giản, code ở development thì không cần optimize gì, devtool source map thì cứ bật lên cho dễ check lỗi... Nhưng ở production, code của project cần được optimize hết sức có thể, để tăng khả năng load trang cho user, lúc ấy thì source map tất nhiên cũng chẳng có ý nghĩa gì.\nThế là sau khi ngộ ra vấn đề, cũng như tham khảo các tiền bối Tây lông, thì mình chia ra được cấu trúc như thế này\n\n![Webpack](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578054\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-2_r8hdag.png)\n\n\n`Project structure`\n```\n...\n...\n├── config\n      ├── addons \u002F\n              └── webpack.addons.js     \n      ├── common-path.js   \u002F* Chứa path input, output, src, blo bla *\u002F\n      ├── webpack.common.js  \n      ├── webpack.dev.js   \n      ├── webpack.prod.js  \n\n└── src \u002F\n└── webpack.config.js\n... \n...\n```\n\u003Cbr\u003E\n\n`webpack.config.js`\n```js\nconst merge = require('webpack-merge');\nconst { mode, analyze } = require('webpack-nano\u002Fargv');\nconst hugCommonConfig = require('.\u002Fconfig\u002Fwebpack.common');\nconst hugDevConfig = require('.\u002Fconfig\u002Fwebpack.dev');\nconst hugProdConfig = require('.\u002Fconfig\u002Fwebpack.prod');\nconst addons = require('.\u002Fconfig\u002Faddons\u002Fwebpack.addons');\n\n\nconst development = merge([\n  hugDevConfig,\n  analyze && addons.analyze(),\n])\n\nconst production = merge([\n  hugProdConfig,\n  analyze && addons.analyze(),\n])\n\nconst getConfig = mode =\u003E {\n  switch(mode) {\n    case 'development':\n      return merge([hugCommonConfig, development])\n    case 'production':\n      return merge([hugCommonConfig, production])\n    default:\n      throw new Error(`Unknow mode, ${mode}`)\n  }\n\n}\nmodule.exports = getConfig(mode);\n```\n\nCác bạn nhìn thấy lúc này file config của mình đã rất ngắn, do mình chia làm 3 file config nhỏ ra. Cụ thể là webpack.common ( là những config có trên cả 2 môi trường ) , webpack.dev ( cho môi trường development) và webpack.prod ( cho môi trường production ), chưa kể các addons ( không có trong config, chỉ xuất hiện khi cần. Ví dụ như  Bundle Analyzer... )\nĐi kèm với config này, mình sẽ có các câu script như sau :\n\n![Webpack](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578054\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-3_qj2xb6.png)\n\n\nThì việc chia như này giúp mình một số việc :\n\n - Tất nhiên đầu tiên là từ 1 file chia ra làm 3, 4 thì nó lại chẳng ngắn vch, đã ngắn thì dễ đọc dễ fix.\n - Các file riêng biệt cho từng môi trường, như vậy không cần phải check xem là môi trường nào lệnh nào như ảnh đầu tiên nữa. Cứ môi trường nào file đấy chạy. \n - Việc merge lúc này đã có webpack-merge giúp mình. Tuỳ vào môi trường là dev hay prod, nó sẽ merge file common + file config của môi trường đấy.\n - Các addon ( một số plugin hỗ trợ ) lúc này có thể chỉ được thêm vào khi cần thiết. Như ảnh trên thì bạn thấy mình có dùng addons là bundleanalyzer. Thì đây là một plugin của webpack giúp mình hình dung ra được sự tương quan về các file size sau khi bundle. Và tất nhiên mình chẳng cần nó ở cả dev và prod, nếu đặt ở common thì lần nào build nó cũng chạy quá tốn thời gian. Thế nên mình để vào addon, dựa trên config kia, chỉ khi nào mình chạy lệnh npm run build:prod:bundleanalyzer thì plugin này mới được thêm vào config. Kết quả trông như thế này \n  \n![Webpack](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578054\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-4_xkbekt.png)\n\n\nNhìn là thấy quả thư viện swiper kia nặng vch.\nỞ nhưng mà chưa hết nhé. Thế nếu chia 3, 4 file như này rồi mà vẫn có file config dài ơi là dài thì làm thế nào. Nhất là file webpack.common kia. Dài thôi rồi luôn. Cái khó ló cái khôn, mình lại bóc tách nhỏ tiếp thêm một lần nữa.\n\n## Chia, chia nữa, chia mãi\nThì quay lại câu chuyện, dù đã chia như kia rồi, nhưng như mình nói, có file vẫn quá dài. Mình còn gặp thêm vấn đề là ở team mình có một số bạn không biết webpack. Thực ra đó là chuyện bình thường, vì config thì chỉ cần một người làm là được rồi.  Nhưng mà thử tưởng tượng cứ cái gì đổi config là các ông cũng réo mình, đổi cái port từ 3000 lên 3001 cũng réo. \nLại một lần nữa cái khó ló cái khôn, với sự chỉ giáo của các tiền bối Tây lông, mình đã cho ra đời chiếc config custom nhỏ hơn nữa, và đặc biệt rất dễ hiểu, dễ sửa với các bạn không biết webpack như team mình.\nTrước tiên, khoe nhẹ cái structure đã\n\n![Webpack](https:\u002F\u002Fres.cloudinary.com\u002Fkmacoders\u002Fimage\u002Fupload\u002Fv1630578053\u002Fkmacoders.github.io\u002Fstatic\u002Fimages\u002Fblog\u002F2021\u002F08\u002F30-webpack-5_jhdzlf.png)\n\n`New structure`\n\n```\n...\n...\n├── config\n      ├── addons \u002F\n              └── webpack.addons.js     \n      ├── parts \u002F\n              ├── webpack.module.js\n              ├── webpack.parts.js\n              ├── webpack.plugin.js\n      ├── common-path.js   \u002F* Chứa path input, output, src, blo bla *\u002F\n      ├── webpack.common.js  \n      ├── webpack.dev.js   \n      ├── webpack.prod.js  \n\n└── src \u002F\n└── webpack.config.js\n... \n...\n```\n\n\nMột folder nữa tên là parts hiện ra. Vậy nó là gì ?\nKhoan hãy nói về thằng parts này, quay lại với các concepts trong webpack. Ngay trên docs webpack đã nói là họ có 5, 6 concepta cơ bản là\n -   [Entry](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#entry)\n-   [Output](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#output)\n-   [Loaders](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#loaders)\n-   [Plugins](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#plugins)\n-   [Mode](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#mode)\n-   [Browser Compatibility](https:\u002F\u002Fwebpack.js.org\u002Fconcepts\u002F#browser-compatibility)\nThế thì tại sao mình không chia nhỏ dựa trên các concepts này và chức năng của chúng. Nôm na thì 3 file common, dev, prod trên kia giờ sẽ biến thành thế này\n\n`webpack.common.js`\n\n```js\nconst  path  =  require('path');\nconst commonPath =  require('.\u002Fcommon-path');\nconst merge =  require('webpack-merge');\nconst parts =  require('.\u002Fparts\u002Fwebpack.parts');\nconst modules =  require('.\u002Fparts\u002Fwebpack.module');\nconst plugins =  require('.\u002Fparts\u002Fwebpack.plugin');\nconst  hugCommonConfig  =  merge([\n\t{ name:  'Vue3 Typescript Starter' },\n\t{ entry:  '.\u002Fsrc\u002Findex.ts' },\n\t{\n\t\toutput: {\n\t\t\tpath: commonPath.outputPath,\n\t\t\tfilename:  'build\u002Fapp.js',\n\t\t\tchunkFilename:  'build\u002Fvendors-script.js'\n\t\t}\n\t},\n\tmodules.loadBabel(),\n\tmodules.loadTypescript(),\n\tmodules.loadVue(),\n\tmodules.loadScss(),\n\tparts.commonOptimize(),\n\tplugins.extractCss({\n\t\tpath: commonPath.outputPath,\n\t\tfilename:  'build\u002Fmain.css',\n\t\tchunkFilename:  'build\u002Fvendors-style.css'\n\t}),\n\n\tplugins.vueLoaderPlugin(),\n\tplugins.buildFeatureFlags(),\n\tplugins.styleLint(),\n\tparts.aliasWebpack(),\n\tparts.statsCommon()\n])\n\n\u002F\u002F Todo\nhugCommonConfig.node = { fs:  'empty'}\nmodule.exports  =  hugCommonConfig\n```\nTức là giờ mỗi một concepts hoặc 1 chức năng ( bunlde vue, bunlde scss... ) đã được đặt thành một function ( các function này được chia thành module, parts, hoặc plugin tuỳ chức năng ) và được gọi vào 3 file webpack.common, webpack.dev và webpack.prod.\n\nVậy thì việc này có tác dụng gì :\n\n - Tất nhiên lại là nó ngắn và gọn thôi rồi.\n - Khi muốn gỡ một chức năng nào đó, ví dụ gỡ styleLint khỏi project, mình chỉ cần đơn giản tìm đến đoạn code này, xoá đi là xong, thay vì phải lục cả đống config như ngày xưa. Nhất đâu xoá nhầm cả cái gì khác, ae code thấy lỗi thì thôi đem gạch về xây nhà.\n\n`webpack.common.js`\n\n```js\n...\nplugins.vueLoaderPlugin(),\nplugins.buildFeatureFlags(),\nplugins.styleLint(), \u002F\u002F xoá đi dòng này là xong\nparts.aliasWebpack(),\nparts.statsCommon()\n...\n```\n- Tiếp là nó giúp cho ae sửa nhanh hơn bao giờ hết. Ví dụ đoạn đổi port, mình config như thế này\n`webpack.dev.js`\n```js\nconst  hugDevConfig  =  merge([\n\t{ mode:  'development' },\n\t{ devtool:  'inline-source-map' },\n\tparts.devServer({port:  5000}), \u002F\u002F đổi chỗ này thành port khác là xong\n\tplugins.cleanDist(),\n\tplugins.copyFromPublicToDist(),\n\tplugins.htmlWebpack(),\n\tparts.statsDev({excludeAssets: [\u002F.liquid\u002F,  \u002F.svg\u002F,  \u002F.min.*\u002F,  \u002F.png\u002F,  \u002F.gif\u002F]}),\n]);\nmodule.exports  =  hugDevConfig;\n```\n\nĐó, muôn vài tiện ích. Quay trở lại với folder parts ban nãy, thì ở bên trong mình chia nhỏ ra theo các concepts rồi viếc các hàm nhỏ chứa config webpack. Ví dụ như chỗ port kia nhé\n\n`webpack.parts.js`\n```js\n...\n...\n\u002F\u002F Hàm devServer ở bên trên. Với port được truyền từ ngoài vào\nexports.devServer = (options) =\u003E ({\n  \u002F\u002F watch: true,\n  devServer: {\n    contentBase: commonPath.outputPath,\n    compress: true,\n    port: options.port,\n  },\n})\n\nexports.statsDev = (options) =\u003E ({\n  \u002F**\n   * Tells stats whether to add information about the built modules.\n   * @see {@link https:\u002F\u002Fwebpack.js.org\u002Fconfiguration\u002Fstats\u002F}\n   *\u002F\n   stats: {\n    excludeAssets: options.excludeAssets,\n    modules: false\n  },\n})\n\nexports.commonOptimize = () =\u003E ({\n  optimization: {\n    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],\n    splitChunks: {\n      cacheGroups: {\n          vendor: {\n              test: \u002F[\\\\\u002F]node_modules[\\\\\u002F]\u002F,\n              name: 'vendors',\n              enforce: true,\n              chunks: 'all'\n          }\n      }\n    }\n  }\n})\n...\n...\n```\n\nHay đây là một ví dụ cho Vue\n\n`webpack.modules.js`\n\n```js\nexports.loadVue = () =\u003E ({\n  module: {\n    rules: [\n      {\n        test: \u002F\\.vue$\u002F,\n        loader: 'vue-loader',\n        options: {\n          loaders: {\n            'scss': 'vue-style-loader!css-loader!sass-loader',\n            'sass': 'vue-style-loader!css-loader!sass-loader?indentedSyntax',\n          },\n        },\n      },\n    ]\n  },\n  resolve: {\n    extensions: ['.vue', '.ts', '.js', '.json'],\n    mainFields: ['vue', 'browser', 'module', 'main']\n  }\n})\n```\nVà ở file common mình gọi\n\n`webpack.common.js`\n\n```js\nmodules.loadBabel(),\nmodules.loadTypescript(),\nmodules.loadVue(), \nmodules.loadScss(),\n```\n\n## Tóm lại\nThực ra ngày mới học mình lên youtube hay google search thì mỗi ông dạy webpack một kiểu. Cũng đúng vì mỗi project mỗi setup khác nhau, làm gì có cái nào giống cái nào. Chưa kể cú pháp của webpack cũng rất lằng nhằng. Thì đây là một chia sẻ của mình, một phương pháp của mình mà mình cho là khá ổn. Nó được xây dựng từ các vấn đề thực tế của team mình trong quá trình làm việc, cũng như là follow theo các anh Tây lông để tối ưu nhất có thể. Cá nhân mình thấy nó khá hay, ít nhất là ở thời điểm hiện tại. Biết đâu trong tương lai khi làm việc với các team khác, cty khác mình lại có những phương pháp khác thì mình lại bên lên đây để kí sự chém gió tiếp.\nThế nhé.\n"}]}],fetch:{},mutations:void 0}}("webpack")));